<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>index (mimic.index)</title><link rel="stylesheet" href="../odoc.support/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.3.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ mimic</nav><header class="odoc-preamble"><h2 id="mimic,-a-small-library-to-abstract-transmission-protocols."><a href="#mimic,-a-small-library-to-abstract-transmission-protocols." class="anchor"></a>Mimic, a small library to abstract transmission protocols.</h2></header><nav class="odoc-toc"><ul><li><a href="#introduction.">Introduction.</a></li><li><a href="#the-solution.">The solution.</a></li><li><a href="#implement-a-protocol-with-mimic.">Implement a protocol with mimic.</a></li><li><a href="#the-client-part.">The client part.</a></li><li><a href="#registration-&amp;-instantiation.">Registration &amp; Instantiation.</a></li><li><a href="#upgrade-tls.">Upgrade TLS.</a></li><li><a href="#the-server-side.">The server side.</a></li></ul></nav><div class="odoc-content"><h3 id="introduction."><a href="#introduction." class="anchor"></a>Introduction.</h3><p>Mimic is a very small library that offers a re-implementation of virtual methods for modules. In a large project such as Git or Irmin, keeping in mind the system abstraction required to be compatible with MirageOS, one question transcends all levels:</p><pre>&gt; How to abstract the network?</pre><p>In the specific context of Unix/<code>&lt;unistd.h&gt;</code>, several functions exist to communicate across the network. In particular the idea of a <em>socket</em>. For most projects, the <em>socket</em> seems to be the common denominator for all transmissions.</p><p>In the case of Git, the <em>socket</em> can represent a simple TCP/IP connection or a transmission through SSH (using a pipe). For HTTP with TLS, the principle remains the same as long as OpenSSL proposes an equivalent of the <em>socket</em> through a derivation of the TCP/IP socket.</p><p>As a proof, <code>Lwt_ssl</code> proposes this same derivation:</p><pre class="language-ocaml"><code>Lwt_ssl.embed_socket : Lwt_unix.file_descr -&gt; Ssl.context -&gt; Lwt_ssl.socket</code></pre><p>In any case, it seems that the <em>socket</em> principle itself is the common denominator to protocols like Git, HTTP or SMTP.</p><p>It happens that MirageOS offers an interface that describes this <em>socket</em>:</p><pre class="language-ocaml"><code>sig
  type error
  type write_error = private [&gt; `Closed ]

  val pp_error : Format.formatter -&gt; error -&gt; unit
  val pp_write_error : Format.formatter -&gt; write_error -&gt; unit

  type flow

  val read : flow -&gt; (Cstruct.t or_eof, error) result Lwt.t
  val write : flow -&gt; Cstruct.t -&gt; (unit, error) result Lwt.t
  val writev : flow -&gt; Cstruct.t list -&gt; (unit, error) result Lwt.t
  val close : flow -&gt; unit Lwt.t
end</code></pre><p><b>NOTE:</b> <code>read</code> is a method that diverges from the <code>read</code>/<code>recv</code> we're used to seeing with <code>&lt;unistd.h&gt;</code> where the latter requests a buffer to write to. Historically, the idea of <code>Mirage_flow.S.read</code> gives the ability to implement a <em>zero-copy</em> stack. Indeed, the <code>Cstruct.t</code> that is returned could directly be the memory page having the TCP/IP packet. Thus, between the TCP/IP driver (the implementation) and the client application, there should be no allocation. However:</p><ul><li>it is not known if this assertion is still true</li><li>it doesn't correspond to anything real for TLS (where there is necessarily a copy)</li></ul><p>With this interface, it can be possible to abstract the socket for protocols like HTTP, Git/Smart or SMTP such as:</p><pre class="language-ocaml"><code>module SMTP  = Make_SMTP  (Tcpip_stack_direct.TCP : Mirage_flow.S)
module HTTP  = Make_HTTP  (Tcpip_stack_direct.TCP : Mirage_flow.S)
module Smart = Make_Smart (Tcpip_stack_direct.TCP : Mirage_flow.S)</code></pre><p>It turns out that <code>ocaml-tls</code> offers a derivation from a given <em>socket</em> described through <code>Mirage_flow.S</code> to a &quot;new&quot; <em>socket</em> with TLS:</p><pre class="language-ocaml"><code>Tls_mirage.Make : functor (_ : Mirage_flow.S) -&gt; Mirage_flow.S</code></pre><p>Therefore, it is possible to upgrade our protocols <b>statically</b> with a TLS layer quite easily:</p><pre class="language-ocaml"><code>module TLS = Tls_mirage.Make (Tcpip_stack_direct.TCP)

module SSMTP = Make_SMTP (TLS)
module HTTPS = Make_HTTP (TLS)</code></pre><p>The problem with this kind of abstraction is the eminently static aspect of this code. Indeed, the choice between SMTP and SSMTP (HTTP or HTTPS) cannot be made when choosing statically these modules.</p><p>This implies that if the type of transmission depends on a value such as an <code>Uri.t</code> (and its <em>scheme</em>), we need to have access to these 2 modules throughout our process.</p><p>Especially since <code>SSMTP</code> or <code>HTTPS</code> are themselves directed by an arbitrary choice which is to use <code>ocaml-tls</code> instead of OpenSSL. It may be essential to let the user choose his TLS implementation.</p><p>We would therefore need:</p><ol><li>a functor for the TCP/IP stack (required for MirageOS)</li><li>a functor that is itself a functor waiting for our common denominator, the socket, and that can derive it into a TLS transmission</li></ol><pre class="language-ocaml"><code>module type Make_SMTP =
  functor (Socket : Mirage_flow.S) -&gt;
  functor (Tls : functor (Socket : Mirage_flow.S) -&gt; Mirage_flow.S) -&gt;
  sig ... end</code></pre><p>Thus, we ensure:</p><ol><li>the possibility to <b>statically</b> choose the TCP/IP stack</li><li>the possibility to <b>statically</b> choose the implementation of the TLS layer</li><li>a way to communicate with TCP/IP within our <code>Make</code></li><li>a way to communicate with TLS within our <code>Make</code></li><li>to propose a function making the <b>dynamic</b> choice between these 2 types of transmission</li></ol><pre class="language-ocaml"><code>module Make_HTTP (Socket : _) (Tls : _) = struct
  module Tls = Tls (Socket)

  let connect uri = match Uri.scheme with
    | Some &quot;https&quot; -&gt; Tls.connect ...
    | Some &quot;http&quot; -&gt; Socket.connect ...
end</code></pre><p>The problem remains in any case the eminently dynamic aspect of the choice of the transmission protocol which requires a static knowledge of what is a <em>socket</em> and what is a <em>socket</em> with TLS. The problem applies as much for Git with SSH.</p><p>This static knowledge required of the modules implementing the <em>socket</em> as well as its possible derivation into a TLS <em>socket</em> puts us in a difficult position when we want to keep the abstraction power of the functors to be compatible with MirageOS - in which neither the TCP/IP nor the TLS implementation can be known globally in advance (in other words, their implementations can only be obtained through a functor).</p><p>In MirageOS, all this complexity of the functors can be reduced with the help of <code>functoria</code> which allows to apply the functors cleanly according to the target. For the example, the TCP/IP stack depends on the target at all since with <code>mirage configure -t unix</code>, we use the host system stack but for <code>mirage configure -t hvt</code>, we use <code>mirage-tcpip</code>.</p><p>Unfortunately, this implies to &quot;keep&quot; this level of abstraction for all libraries depending on our SMTP/HTTP/Smart implementation if they want to keep the compatibility with MirageOS.</p><p>A &quot;shift&quot; on the functors then occurs systematically which leads to an exponential progression of the number of functors as one advances from layer to layer.</p><p>For example, Irmin with Git will have to integrate at the same time:</p><ul><li>a functor for the TCP/IP stack</li><li>a functor for TLS (which itself is a functor on the TCP/IP stack)</li><li>a functor for the HTTP stack which is a functor on the TCP/IP and the TLS stack</li><li>a functor for SSH which itself is a functor on the TCP/IP stack</li><li>and we are talking about communication (you can include the hash algorithm, the format of your values, etc.)</li></ul><p>It is only through all of these functors that we can:</p><ol><li>be perfectly abstract</li><li>always be able to propose a &quot;dispatch&quot; of these protocols in a dynamic way</li><li>never arbitrarily choose an implementation or more specifically a type representing these <em>sockets</em></li></ol><h3 id="the-solution."><a href="#the-solution." class="anchor"></a>The solution.</h3><p>After this &quot;brief&quot; introduction, it is now time to talk about the solution! But it seems clear that if we wanted to essentialize the problem, it would simply be to say:</p><pre>&gt; how to get a protocol implementation dynamically and without functors?</pre><p>In the previous explanations we mentioned <code>Mirage_flow.S</code>. It turns out that it is canonical to any transmission protocol. It allows to describe the TCP/IP protocol, the TCP/IP protocol with TLS or the SSH protocol because in these 3 cases, we only want to:</p><ul><li>read</li><li>and write</li></ul><p>The abstraction does not work however when it comes to instantiating the <em>socket</em>. Indeed, a TCP/IP transmission only requires an IP address and a port. However, SSH requires much more such as an RSA key.</p><p>Conduit 2.0 assumes that these instantiation methods must be known statically. An ADT describes these methods and if it is not exhaustive, it corresponds to the usual cases such as HTTPS or SSMTP.</p><p>However, we could also say that for protocols like SSMTP or HTTPS (or SMTP or HTTP), these instantiation methods are not our concern. Again, we would just like to be able to read and write.</p><h3 id="implement-a-protocol-with-mimic."><a href="#implement-a-protocol-with-mimic." class="anchor"></a>Implement a protocol with mimic.</h3><p>In the end, mimic provides an implementation of <code>Mirage_flow.S</code> that is directly usable without functors. So we will start implementating a simple protocol, a ping-pong to show how to implement a protocol (like HTTP, SMTP or Smart) with mimic.</p><pre class="language-ocaml"><code>open Rresult
open Lwt.Infix

let ( &gt;&gt;? ) = Lwt_result.bind

let blit src src_off dst dst_off len =
  Bigstringaf.blit_to_bytes src ~src_off dst ~dst_off ~len

let line_of_queue queue =
  let exists ~p queue =
    let pos = ref 0 and res = ref (-1) in
    Ke.Rke.iter (fun chr -&gt; if p chr &amp;&amp; !res = -1 then res := !pos
                          ; incr pos) queue ;
    if !res = -1 then None else Some !res in
  match exists ~p:((=) '\n') queue with
  | None -&gt; None
  | Some 0 -&gt; Ke.Rke.N.shift_exn queue 1 ; Some &quot;&quot;
  | Some pos -&gt;
    let tmp = Bytes.create pos in
    Ke.Rke.N.keep_exn queue ~blit ~length:Bytes.length ~off:0 ~len:pos tmp ;
    Ke.Rke.N.shift_exn queue (pos + 1) ;
    match Bytes.get tmp (pos - 1) with
    | '\r' -&gt; Some (Bytes.sub_string tmp 0 (pos - 1))
    | _ -&gt; Some (Bytes.unsafe_to_string tmp)

let blit src src_off dst dst_off len =
  let src = Cstruct.to_bigarray src in
  Bigstringaf.blit src ~src_off dst ~dst_off ~len

let rec getline flow queue = match line_of_queue queue with
  | Some line -&gt; Lwt.return_ok (`Line line)
  | None -&gt;
    Mimic.read flow &gt;&gt;= function
    | Ok `Eof -&gt; Lwt.return_ok `Close
    | Ok (`Data v) -&gt;
      Ke.Rke.N.push queue ~blit ~length:Cstruct.length ~off:0 v ;
      getline flow queue
    | Error err -&gt; Lwt.return_error (R.msgf &quot;%a&quot; Mimic.pp_error err)

let sendline flow fmt =
  let send str =
    Mimic.write flow (Cstruct.of_string str) &gt;&gt;= function
    | Ok _ as v -&gt; Lwt.return v
    | Error err -&gt; Lwt.return_error (R.msgf &quot;%a&quot; Mimic.pp_write_error err) in
  Fmt.kstr send (fmt ^^ &quot;\r\n&quot;)</code></pre><p>This code is quite simple. It implements logic that is usually available with a standard library. Of course, <code>Mirage_flow.S</code> does not give us these functions (but <code>Mirage_channel</code> does).</p><p>These logics are the protocol as we can define it. For example, SMTP or HTTP could be implemented with these functions. As for Smart, it's another matter since it uses another format - or rather, this protocol is not &quot;line-directed&quot;.</p><p>But what is most important is the possibility to directly implement a protocol without using a functor to abstract the implementation of the transmission. In this sense, mimic could very well be TCP/IP than TLS or SSH. At this stage, we don't know and that's the point!</p><p>You can compile the code with:</p><pre class="language-ocaml"><code>$ ocamlfind opt -linkpkg -package rresult,lwt,mimic,bigstringaf,cstruct,ke \
    main.ml</code></pre><p>Once again, we can denote the dependencies necessary for compilation. There is no question of <code>unix</code>. At the beginning of this explanation, we talked about <code>&lt;unistd.h&gt;</code> as the common denominator to get our <em>socket</em>. Here we are saying that our <em>socket</em> <b>is</b> mimic. Of course, mimic is compatible with MirageOS.</p><h3 id="the-client-part."><a href="#the-client-part." class="anchor"></a>The client part.</h3><p>So let's start implementing the client as it should be.</p><pre class="language-ocaml"><code>let client ~ctx ic =
  let rec go flow queue = match input_line ic with
    | line -&gt;
      if ic != stdin then Fmt.pr &quot;&gt; %s\n%!&quot; line ;
      sendline flow &quot;%s&quot; line &gt;&gt;? fun () -&gt;
      ( getline flow queue &gt;&gt;? function
      | `Close -&gt; Lwt.return_ok ()
      | `Line v -&gt;
        Fmt.pr &quot;&lt;- %s\n%!&quot; v ;
	if ic == stdin then Fmt.pr &quot;&gt; %!&quot; ;
	go flow queue )
    | exception End_of_file -&gt; Lwt.return_ok () in
  Mimic.resolve ctx &gt;&gt;? fun flow -&gt;
  let queue = Ke.Rke.create ~capacity:0x1000 Bigarray.char in
  if ic == stdin then Fmt.pr &quot;&gt; %!&quot; ;
  go flow queue &gt;&gt;= fun res -&gt;
  Mimic.close flow &gt;&gt;= fun () -&gt; Lwt.return res</code></pre><p>In this small piece of code, we see the appearance of a function that is not part of <code>Mirage_flow.S</code> but strictly speaking of mimic. It's <code>Mimic.resolve</code>.</p><p>It was said earlier that the instantiation of a <em>socket</em> is not the privilege of the protocol itself. Indeed, once again, as far as our ping-pong protocol is concerned, our &quot;line-directed&quot; protocol (just like SMTP or HTTP again) does not care how to initialize a transmission. It just wants to be able to read and write.</p><p>Thus, <code>Mimic.resolve</code> seems a bit magical but the instantiation of a <em>socket</em> ultimately depends on a single value, the <code>ctx</code>. The context is a representation of what is allowed to do according to the end user. It contains elements that allow the famous dynamic &quot;dispatch&quot; to instantiate a <em>socket</em>.</p><p>In other words, it is through the context that we determine the type of transmission: if it is a TCP/IP or TLS transmission for example.</p><p>We will then see how to define this context and how it works to choose this or that type of transmission. The important thing to keep in mind is that we have just done:</p><ol><li>implement our ping-pong protocol - at least, the client part</li><li>this code will not change when it comes to upgrade the transmission with TLS</li><li>this code is compatible with MirageOS</li></ol><p>The logic of this code is very simple, it passes what it has from an <code>in_channel</code> to the server and that's it! It is important to understand that what follows must be external to the implementation of the protocol itself, because we will start to explain to mimic the instantiation of the transmission techniques.</p><p>As a concrete example, <code>ocaml-git</code> is separated in 3 where <code>git</code> implements the Smart protocol, <code>git-unix</code> registers the Unix specific transmission types and <code>git-mirage</code> does the same with MirageOS compatible implementations (<code>mirage-tcpip</code>, <code>tls-mirage</code> or <code>awa-ssh</code>).</p><p>This part will directly depend on the said transmission protocols like TCP/IP or TLS. These choices are therefore outside the implementation of the ping-pong protocol itself.</p><h3 id="registration-&amp;-instantiation."><a href="#registration-&amp;-instantiation." class="anchor"></a>Registration &amp; Instantiation.</h3><p>Mimic offers a way to &quot;fill&quot; the context with values. These values are needed to instantiate one of your transmission protocols. As we said, for TCP/IP, the instantiation of a <em>socket</em> requires to get an IP address and a port.</p><p>So, if we &quot;fill&quot; our context with these values, mimic can initialize a TCP/IP connection. More generally, 2 steps are necessary for mimic to establish a transmission:</p><ol><li>know the transmission protocol and what it requires</li><li>add what it requires in a context</li></ol><p>The first step is quite unusual. It consists in &quot;registering&quot; a transmission protocol with mimic. This is a prerequisite for extending the protocols available through mimic - and of course, initially, mimic does not know any protocols (again, to be compatible with MirageOS).</p><p>It is accepted, as we said from the beginning, that a transmission protocol can described with <code>Mirage_flow.S</code>. As for <code>mirage-tcpip</code>, <code>ocaml-tls</code> or <code>awa-ssh</code>, all three implementations respect the <code>Mirage_flow.S</code> interface.</p><p>And this is what mimic expects, a protocol that respects <code>Mirage_flow.S</code>. However, mimic expects an extension to this interface. Indeed, beyond being able to relay the <code>read</code> and <code>write</code> of your implementations to the implementation of your ping-pong protocol, mimic also depends on an &quot;instantiation&quot; method. In other words, mimic requires a module respecting <code>Mirage_flow.S</code> and a <code>connect</code> function: <a href="Mimic/Mirage_protocol/module-type-S/index.html"><code>Mimic.Mirage_protocol.S</code></a>.</p><p>Let's take <code>mirage-tcpip</code> as an example. We need to tweak its implementation a bit in order to register it with mimic.</p><pre class="language-ocaml"><code>module TCP = struct
  include Tcpip_stack_socket.V4V6.TCP

  let pp_write_error ppf = function
    | #write_error as err -&gt; pp_write_error ppf err
    | `Error err -&gt; pp_error ppf err

  type endpoint = t * Ipaddr.t * int
  type nonrec write_error = [ write_error | `Error of error ]

  let write flow cs = write flow cs &gt;&gt;= function
    | Ok _ as v -&gt; Lwt.return v
    | Error err -&gt; Lwt.return_error (err :&gt; write_error)

  let writev flow css = writev flow css &gt;&gt;= function
    | Ok _ as v -&gt; Lwt.return v
    | Error err -&gt; Lwt.return_error (err :&gt; write_error)

  let connect (stack, ipaddr, port) =
    create_connection stack (ipaddr, port)
    &gt;|= R.reword_error (fun err -&gt; `Error err)
end

let tcp_edn, tcp_protocol = Mimic.register ~name:&quot;tcp&quot; (module TCP)</code></pre><p>We have just registered the TCP/IP transmission protocol and mimic has returned 2 values:</p><ol><li>a <i>witness</i> of what is required to instantiate a TCP/IP transmission with this <code>TCP</code> module</li><li>a <i>witness</i> of our <code>TCP</code> implementation</li></ol><p><b>NOTE:</b> it may be difficult to understand why we need to tweak <code>mirage-tcpip</code>. In fact, if mimic really wants to be a means of abstracting transmission protocols, one must admit the idea that instantiating a protocol may require writing something. This is the case for TLS which performs a <i>handshake</i> with the server at instantiation. Thus, we must allow <code>connect</code> to return a writing error.</p><p><code>tcp_edn</code> is a value that represents what is required from our <code>connect</code>. Its type depends explicitely on the way our implementation instantiates our socket. In other words, in our example, its type is:</p><pre class="language-ocaml"><code>val tcp_edn : (TCP.t * Ipaddr.t * int) Mimic.value</code></pre><p>This <i>witness</i> is useful to &quot;fill in&quot; a context that we could then pass to our client. The idea is that if a value <i>of type</i> <code>tcp_edn</code> exists in the <code>ctx</code> context used by <code>Mimic.resolve</code>, mimic is able to instantiate a TCP/IP transmission and use your <code>TCP</code> module instead of <code>Mimic.{read,write,close}</code>.</p><p>So let's try to use our code. In a shell, it makes us launch a server with <code>nc -l 8080</code>. Then we need to run out client.</p><pre class="language-ocaml"><code>let ctx00 stack ipaddr port =
  Mimic.empty
  |&gt; Mimic.add tcp_edn (stack, ipaddr, port)

let run00 uri ic = match Uri.host uri, Uri.port uri with
  | None, None
  | Some _, None
  | None, Some _ -&gt; Fmt.failwith &quot;Invalid uri: %a&quot; Uri.pp uri
  | Some host, Some port -&gt; match Ipaddr.of_string host with
    | Ok ipaddr -&gt;
      let open Tcpip_stack_socket.V4V6 in
      TCP.connect ~ipv4_only:false ~ipv6_only:false Ipaddr.V4.Prefix.global
        None &gt;&gt;= fun tcp -&gt;
      let ctx = ctx00 tcp ipaddr port in
      client ~ctx ic
    | Error _ -&gt; Fmt.failwith &quot;Invalid IP address: %s&quot; host

let _0 () = match Sys.argv with
  | [| _; uri; |] -&gt;
    Lwt_main.run (run00 (Uri.of_string uri) stdin)
    |&gt; R.reword_error (R.msgf &quot;%a&quot; Mimic.pp_error)
    |&gt; R.failwith_error_msg
  | [| _; uri; filename; |] when Sys.file_exists filename -&gt;
    let ic = open_in filename in
    let rs = Lwt_main.run (run00 (Uri.of_string uri) ic) in
    close_in ic ;
    R.failwith_error_msg (R.reword_error (R.msgf &quot;%a&quot; Mimic.pp_error) rs)
  | _ -&gt; Fmt.epr &quot;%s &lt;uri&gt; [filename]\n%!&quot; Sys.argv.(0)</code></pre><p>The code is compilable with</p><pre class="language-ocaml"><code>$ ocamlfind opt -thread -package rresult,lwt,mimic,bigstringaf,cstruct,ke, \
    tcpip.stack-socket,uri main.ml</code></pre><p>Then we just need to execute our code such that <code>$</code> is our client and <code>#</code> is our server:</p><pre class="language-ocaml"><code># nc -l 8080
$ ./a.out tcp://127.0.0.1:8080/
$&gt; ping
#ping
#pong
$&lt;- pong</code></pre><p>We have several limitations here:</p><ol><li>we have to specify the IP address</li><li>we have to specify a port</li><li>we are finally limited to full our context with a value <code>TCP.t * Ipaddr.t * int</code></li></ol><p>However, we have something that works without having changed any of the code of our ping-pong protocol. Let's take the time to explain once again what just happened. Giving the client a context containing the information required to instantiate a TCP/IP socket causes mimic to be able to execute <code>TCP.connect</code> with these arguments. Let's not forget that it is because we took care to use <code>tcp_edn</code> that <code>mimic</code> is able to do this.</p><p>Since the <code>connect</code> works and returns a <code>TCP.flow</code> (not an error), mimic can &quot;hide&quot; this value under the <code>Mimic.flow</code> type used in our client code.</p><p>Finally, <code>Mimic.read</code> and <code>Mimic.write</code>, since they handle a <code>Mimic.flow</code>, they have the ability to &quot;introspect&quot; the hidden <code>TCP.flow</code> and call to <code>TCP.read</code> and <code>TCP.write</code> respectively. This possibility comes from the fact that we have &quot;registered&quot; our <code>TCP</code> protocol with mimic (with <code>Mimic.register</code>).</p><p>Now we can try to solve our limitations. Indeed, mimic provides an API to:</p><ol><li>create other <i>witnesses</i></li><li><i>populate</i> the context with functions that manipulate added values with using the <i>witnesses</i>.</li></ol><p>For the exemple, we will try to manage domain names rather than IP addresses. Thanks to this, we will be able to write <code>&quot;tcp://localhost/&quot;</code>. Also, we will set a default value for the port.</p><p>Again, we need to remember to be compatible with MirageOS. It may be &quot;simple&quot; to manage the domain name &quot;localhost&quot;, but behind this resolution, the process is more complexe than one might imagine. It can be similar to a DNS query on the network. Of course, this kind of mechanism does not exist - at least not without wish - with MirageOS. In our case, since we already depend on <code>unix</code>, we can directly use <code>Unix.gethostbyname</code>.</p><p>In the context of MirageOS, like <code>ocaml-git</code> (see <code>git-mirage</code>), we will use Functoria to add or not the DNS resolution.</p><pre class="language-ocaml"><code>let port : int Mimic.value = Mimic.make ~name:&quot;port&quot;
let ipaddr : Ipaddr.t Mimic.value = Mimic.make ~name:&quot;ipaddr&quot;
let domain_name : [ `host ] Domain_name.t Mimic.value =
  Mimic.make ~name:&quot;domain-name&quot;
let stack : Tcpip_stack_socket.V4V6.TCP.t Mimic.value =
  Mimic.make ~name:&quot;stack&quot;

let ctx01 =
  let open Mimic in
  let k0 v = match Unix.gethostbyname (Domain_name.to_string v) with
    | { Unix.h_addr_list; _ } -&gt;
      if Array.length h_addr_list &gt; 0
      then Lwt.return_some (Ipaddr_unix.of_inet_addr h_addr_list.(0))
      else Lwt.return_none
    | exception _ -&gt; Lwt.return_none in
  let k1 stack ipaddr port = Lwt.return_some (stack, ipaddr, port) in
  Mimic.empty
  |&gt; Mimic.fold ipaddr Fun.[ req domain_name ] ~k:k0
  |&gt; Mimic.fold tcp_edn Fun.[ req stack; req ipaddr; dft port 8080 ] ~k:k1</code></pre><p>We have a new context that does not contain the values required to instantiate a TCP/IP transmission. However, it contains 2 important processes that allow to &quot;resolve&quot; some values into others.</p><p>This is the case more concretely with DNS resolution where we go from a domain name to an IP address. If we add a domain name to this context, mimis is smart enough to try to get an IP address using <code>k0</code>.</p><p>Finally, the second process <code>k1</code> allows to gather some values if they exist (except for the port which has a default value of <code>8080</code>) and to produce a value of type <code>tcp_edn</code>.</p><p>Thus, we now that the ability to instantiate a TCP/IP socket by different means and different values:</p><ul><li>with a domain name</li><li>with a domain name and a port</li><li>with an IP address</li><li>with an IP address and a port</li></ul><p>We can thus make our deconstruction of the <code>Uri.t</code> a little more complex.</p><pre class="language-ocaml"><code>let run01 uri ic =
  let ctx = ctx01 in
  let ctx = match Uri.port uri with
    | Some v -&gt; Mimic.add port v ctx
    | None -&gt; ctx in
  let ctx = match Uri.host uri with
    | None -&gt; ctx
    | Some v -&gt;
      match Rresult.(Domain_name.(of_string v &gt;&gt;= host)),
            Ipaddr.of_string v with
      | Ok v, _ -&gt; Mimic.add domain_name v ctx
      | _, Ok v -&gt; Mimic.add ipaddr v ctx
      | _ -&gt; ctx in
  let open Tcpip_stack_socket.V4V6 in
  TCP.connect ~ipv4_only:false ~ipv6_only:false Ipaddr.V4.Prefix.global
    None &gt;&gt;= fun tcp -&gt;
  let ctx = Mimic.add stack tcp ctx in
  client ~ctx ic

let _1 () = match Sys.argv with
  | [| _; uri; |] -&gt;
    Lwt_main.run (run01 (Uri.of_string uri) stdin)
    |&gt; R.reword_error (R.msgf &quot;%a&quot; Mimic.pp_error)
    |&gt; R.failwith_error_msg
  | [| _; uri; filename; |] when Sys.file_exists filename -&gt;
    let ic = open_in filename in
    let rs = Lwt_main.run (run01 (Uri.of_string uri) ic) in
    close_in ic ;
    R.failwith_error_msg (R.reword_error (R.msgf &quot;%a&quot; Mimic.pp_error) rs)
  | _ -&gt; Fmt.epr &quot;%s &lt;uri&gt; [filename]\n%!&quot; Sys.argv.(0)</code></pre><p>We can say that we finally have a correct &quot;endpoint&quot; mangement using an <code>Uri.t</code>. But what is important is the ability to choose the endpoint independently of the logic of our ping-pong protocol</p><p>This is another important aspect of mimic, it only recognizes the context <code>ctx</code> which, in the end, is a heterogeneous set of values. These values can come from any canonical representation of your endpoin. In our case, we use an <code>Uri.t</code> but another representation can be used.</p><p>This is the case between <code>paf</code> (an HTTP/AF abstraction layer compatible with MirageOS) and Git. One requires an <code>Uri.t</code> as a canonical representation of a target while the other defines its own <code>Smart_git.Endpoint.t</code> type since the target can be represented by an email address (like <code>git@github.com:mirage/ocaml-git</code>).</p><p>In short, all of this shows us a rather fine control of the &quot;dispatch&quot;. mimic just tries to put the pieces together and find a way to create values respecting the prerequisite of your protocols in order to instantiate them.</p><h3 id="upgrade-tls."><a href="#upgrade-tls." class="anchor"></a>Upgrade TLS.</h3><p>We will now see how to upgrade all our code to use TLS.</p><pre class="language-ocaml"><code>module TLS = struct
  include Tls_mirage.Make(Tcpip_stack_socket.V4V6.TCP)

  type endpoint =
    Tcpip_stack_socket.V4V6.TCP.t
    * Tls.Config.client * [ `host ] Domain_name.t option
    * Ipaddr.t * int

  let connect (stack, tls, host, ipaddr, port) =
    let open Tcpip_stack_socket.V4V6 in
    TCP.create_connection stack (ipaddr, port)
    &gt;|= R.reword_error (fun err -&gt; `Read err)
    &gt;&gt;? fun flow -&gt;
    client_of_flow tls ?host flow
end

let tls_edn, tls_protocol = Mimic.register ~priority:10 ~name:&quot;tls&quot;
  (module TLS)

let authenticator ?ip:_ ~host:_ _ = Ok None
let default = Tls.Config.client ~authenticator ()

let tls : Tls.Config.client Mimic.value = Mimic.make ~name:&quot;tls-config&quot;
let scheme : string Mimic.value = Mimic.make ~name:&quot;scheme&quot;

let ctx02 =
  let open Mimic in
  let k0 scheme stack tls domain_name ipaddr port = match scheme with
    | &quot;tls&quot; -&gt; Lwt.return_some (stack, tls, domain_name, ipaddr, port)
    | _ -&gt; Lwt.return_none in
  let k1 scheme stack ipaddr port = match scheme with
    | &quot;tcp&quot; -&gt; Lwt.return_some (stack, ipaddr, port)
    | _ -&gt; Lwt.return_none in
  Mimic.empty
  |&gt; Mimic.fold tls_edn
    Fun.[ req scheme; req stack; dft tls default; opt domain_name
        ; req ipaddr; dft port 4343 ] ~k:k0
  |&gt; Mimic.fold tcp_edn
    Fun.[ req scheme; req stack; req ipaddr; dft port 8080 ] ~k:k1</code></pre><p>Here, the method remains the same as for <code>TCP</code>. We create the module and then register it with mimic. We have two new values which allow us to better specify ths &quot;dispatch&quot; according to the <i>scheme</i>.</p><p>Finally, we have a new context allowing to instantiate a TLS <em>socket</em> according to some values, some of which have a default value. We can finally complete the deconstruction of our <code>Uri.t</code> once again to manage all these parameters.</p><pre class="language-ocaml"><code>let run02 uri ic =
  let ctx = Mimic.merge ctx01 ctx02 in
  let ctx = match Uri.scheme uri with
    | Some v -&gt; Mimic.add scheme v ctx
    | None -&gt; ctx in
  let ctx = match Uri.port uri with
    | Some v -&gt; Mimic.add port v ctx
    | None -&gt; ctx in
  let ctx = match Uri.host uri with
    | None -&gt; ctx
    | Some v -&gt;
      match Rresult.(Domain_name.(of_string v &gt;&gt;= host)),
            Ipaddr.of_string v with
      | Ok v, _ -&gt; Mimic.add domain_name v ctx
      | _, Ok v -&gt; Mimic.add ipaddr v ctx
      | _ -&gt; ctx in
  let open Tcpip_stack_socket.V4V6 in
  TCP.connect ~ipv4_only:false ~ipv6_only:false Ipaddr.V4.Prefix.global
    None &gt;&gt;= fun tcp -&gt;
  let ctx = Mimic.add stack tcp ctx in
  client ~ctx ic

let () = Mirage_crypto_rng_unix.initialize ()

let _2 () = match Sys.argv with
  | [| _; uri; |] -&gt;
    Lwt_main.run (run02 (Uri.of_string uri) stdin)
    |&gt; R.reword_error (R.msgf &quot;%a&quot; Mimic.pp_error)
    |&gt; R.failwith_error_msg
  | [| _; uri; filename |] when Sys.file_exists filename -&gt;
    let ic = open_in filename in
    let rs = Lwt_main.run (run02 (Uri.of_string uri) ic) in
    close_in ic ;
    R.failwith_error_msg (R.reword_error (R.msgf &quot;%a&quot; Mimic.pp_error) rs)
  | _ -&gt; Fmt.epr &quot;%s &lt;uri&gt; [filename]\n%!&quot; Sys.argv.(0)</code></pre><p>These is a lot to say here and to do in order to test this code. First of all we note the use of <a href="Mimic/index.html#val-merge"><code>Mimic.merge</code></a> which allows to merge 2 contexts to obtain only one. To avoid code repetition, we will reuse <code>ctx01</code> which contains our DNS resolver.</p><p>Then we add the scheme from the given <code>Uri.t</code>.</p><p>To launch a TLS server, nothing more than:</p><pre class="language-ocaml"><code># openssl req -x509 -newkey rsa:2048 -keyout key.pem -out cert.pem \
    -days 365 -nodes
# openssl s_server -key key.pem -cert cert.pem -accept 4343</code></pre><p>As for our client, we need to compile it with:</p><pre class="language-ocaml"><code>$ ocamlfind opt -thread -linkpkg -package \
    rresult,lwt,\
    mimic,bigstringaf,cstruct,ke,tcpip.stack-socket,uri,tls-mirage,\
    mirage-crypto-rng.unix main.ml
$ ./a.out tls://localhost:4343/
&gt; ping
#ping
#pong
&lt;- pong
&gt; ^D
#DONE</code></pre><p>And that's it! Again, as an example, the extension from one protocol to another is completely transparent to the protocol ping-pong logic. As you can see, mimic is very minimal but it allows a lot of things. The ability to integrate complex processes into the context allows us to extend what we are able to handle.</p><p>Of course, the minimal aspect of mimic is in the spirit of MirageOS. In the end, mimic only allows one thing: re-implementing virtual methods for modules. The discrimination of available implementations in what is comparable to a <i>vtable</i> (in C++) is done for the context.</p><p>Finally the functions that are in the context can fail as well. In this case, mimic tries other solutions. This situation explains another parameter used in our exemple for TLS, the priority. This ensures that even if the required information for <code>tcp_edn</code> exists, mimic will first try to instantiate a TLS transmission (if, again, all information is available).</p><p>We can finally apply to implement the server now.</p><h3 id="the-server-side."><a href="#the-server-side." class="anchor"></a>The server side.</h3><p>Mimic make the choice to let the user the way the server is made. Indeed, there is a real difference between a client and a server. There is a dynamic part in the choice of the transmission protocol as a client but it is especially not the case for the server where we know exactly how to launch our server.</p><p>Indeed, everything that is initialization or the logic of the main loop remains outside mimic. However, mimic intervenes at one point. As a server, it has to manage clients that do both reading and writing. It can be interesting to implement the client management, the &quot;handler&quot; or the &quot;callback&quot; with mimic.</p><p>The goal is to implement this logic with mimic and we will explain the way to pass from a TCP/IP or TLS socket to a <a href="Mimic/index.html#type-flow"><code>Mimic.flow</code></a>. We call this process: <em>injection</em>.</p><p><b>NOTE:</b> we will redefine <code>TCP</code> and <code>TLS</code> to use the TCP/IP stack of the host system directly this time using <code>Lwt_unix.file_descr</code>. Besides showing another example of how to &quot;register&quot; other protocols, we are required to do this for the simple reason that <code>mirage-tcpip</code> offers a different server logic/interface. Indeed, for Unix/<code>&lt;unistrd.h&gt;</code>, we are used to the triptik <code>socket</code>/<code>accept</code>/<code>close</code>. <code>mirage-tcpip</code> proposes a more &quot;functional&quot; interface with a listen function that registers your callback internally. Finally, <code>mirage-tcpip</code> implements its own main loop. Of course, all this is required because we cannot switch from an <code>Unix.file_descr</code> to a <code>mirage-tcpip</code> <em>socker</em>.</p><p>In order to not lose anyone and to have a coherent understanding of what is usually done when implementing a server, we have to reimplement <code>TCP</code> and <code>TLS</code> with <code>Unix.file_descr</code> and use these modules as our transmission protocols.</p><pre class="language-ocaml"><code>let handler flow =
  let queue = Ke.Rke.create ~capacity:0x1000 Bigarray.char in
  let rec go flow queue =
    getline flow queue &gt;&gt;? function
    | `Close -&gt; Lwt.return_ok ()
    | (`Line &quot;ping&quot;) -&gt; sendline flow &quot;pong&quot; &gt;&gt;? fun () -&gt; go flow queue
    | (`Line &quot;pong&quot;) -&gt; sendline flow &quot;ping&quot; &gt;&gt;? fun () -&gt; go flow queue
    | (`Line line) -&gt; sendline flow &quot;%s&quot; line &gt;&gt;? fun () -&gt; go flow queue in
  go flow queue &gt;&gt;= fun res -&gt;
  Mimic.close flow &gt;&gt;= fun () -&gt; Lwt.return res

let handler flow =
  handler flow &gt;&gt;= function
  | Ok () -&gt; Lwt.return_unit
  | Error err -&gt;
    Fmt.epr &quot;Got an error: %a.\n%!&quot; Mimic.pp_error err ;
    Lwt.return_unit

module TCP' = struct
  type flow = Lwt_unix.file_descr

  type error = [ `Error of Unix.error * string * string ]
  type write_error = [ `Closed | `Error of Unix.error * string * string ]

  let pp_error ppf = function
    | `Error (err, f, v) -&gt;
      Fmt.pf ppf &quot;%s(%s) : %s&quot; f v (Unix.error_message err)

  let pp_write_error ppf = function
    | #error as err -&gt; pp_error ppf err
    | `Closed -&gt; Fmt.pf ppf &quot;Connection closed by peer&quot;

  let read fd =
    let tmp = Bytes.create 0x1000 in
    let process () =
      Lwt_unix.read fd tmp 0 (Bytes.length tmp) &gt;&gt;= function
      | 0 -&gt; Lwt.return_ok `Eof
      | len -&gt; Lwt.return_ok (`Data (Cstruct.of_bytes ~off:0 ~len tmp)) in
    Lwt.catch process @@ function
    | Unix.Unix_error (e, f, v) -&gt; Lwt.return_error (`Error (e, f, v))
    | exn -&gt; Lwt.fail exn

  let write fd ({ Cstruct.len; _ } as cs) =
    let rec process buf off max =
      Lwt_unix.write fd buf off max &gt;&gt;= fun len -&gt;
      if max - len = 0 then Lwt.return_ok ()
      else process buf (off + len) (max - len) in
    let buf = Cstruct.to_bytes cs in
    Lwt.catch (fun () -&gt; process buf 0 len) @@ function
    | Unix.Unix_error (e, f, v) -&gt; Lwt.return_error (`Error (e, f, v))
    | exn -&gt; Lwt.fail exn

  let rec writev fd = function
    | [] -&gt; Lwt.return_ok ()
    | x :: r -&gt; write fd x &gt;&gt;? fun () -&gt; writev fd r

  let close fd = Lwt_unix.close fd

  type endpoint = Lwt_unix.sockaddr

  let connect sockaddr =
    let process () =
      let domain = Unix.domain_of_sockaddr sockaddr in
      let socket = Lwt_unix.socket domain Unix.SOCK_STREAM 0 in
      Lwt_unix.connect socket sockaddr &gt;&gt;= fun () -&gt;
      Lwt.return_ok socket in
    Lwt.catch process @@ function
    | Unix.Unix_error (e, f, v) -&gt; Lwt.return_error (`Error (e, f, v))
    | exn -&gt; Lwt.fail exn
end

module TLS' = struct
  include Tls_mirage.Make(TCP')

  type endpoint =
    Tls.Config.client * [ `host ] Domain_name.t option
    * Unix.sockaddr

  let connect (tls, host, sockaddr) =
    TCP'.connect sockaddr
    &gt;|= R.reword_error (fun err -&gt; `Read err)
    &gt;&gt;? fun flow -&gt;
    client_of_flow tls ?host flow
end

let _, tcp_protocol = Mimic.register ~name:&quot;tcp&quot; (module TCP')
let _, tls_protocol = Mimic.register ~name:&quot;tls&quot; (module TLS')

module TCPRepr = (val (Mimic.repr tcp_protocol))
module TLSRepr = (val (Mimic.repr tls_protocol))</code></pre><p>This time the values we are interested in are the protocols' witnesses. These allow us to create a module exposing the constructor that extends our <a href="Mimic/index.html#type-flow"><code>Mimic.flow</code></a> type.</p><p>This constructor is obtained with the help of <a href="Mimic/index.html#val-repr"><code>Mimic.repr</code></a>. In out example, we obtain modules that continue a type <code>t</code> but above all, they expose a constructor <code>T</code> that allows us to inject our socket as <a href="Mimic/index.html#type-flow"><code>Mimic.flow</code></a> type.</p><p>Thus, we can create a <a href="Mimic/index.html#type-flow"><code>Mimic.flow</code></a> value from our <code>Lwt_unix.file_descr</code> socket by doing:</p><pre class="language-ocaml"><code>let flow : Mimic.flow = TCPRepr.T socket in</code></pre><p>The same is true for TLS, which has a different type - and thus, a different constructor.</p><pre class="language-ocaml"><code>let flow : Mimic.flow = TLSRepr.T socket in</code></pre><p>The rest of the code is the application part of what we just did. We can compile the code with:</p><pre class="language-ocaml"><code>$ ocamlfind opt -thread -linkpkg -package \
    mimic,bigstringaf,cstruct,ke,tcpip.stack-socket,uri,tls-mirage,\
    mirage-crypto-rng.unix main.ml</code></pre><p>Finally, the server side runs with <code>#</code> and the client side with <code>$</code>:</p><pre class="language-ocaml"><code># ./a.out server cert.pem key.pem 4343
# ./a.out 8080
$ ./a.out client tcp://localhost:8080/
$ ./a.out client tsl://localhost:4343/</code></pre><pre class="language-ocaml"><code>type ('v, 'flow, 'err) service =
  { accept : 'v -&gt; ('flow, 'err) result Lwt.t
  ; close : 'v -&gt; unit Lwt.t }
  constraint 'err = [&gt; `Closed ]

let serve_when_ready ?stop ~handler { accept; close; } service =
  `Initialized
    (let switched_off =
       let t, u = Lwt.wait () in
       Lwt_switch.add_hook stop (fun () -&gt;
           Lwt.wakeup_later u (Ok `Stopped) ;
           Lwt.return_unit) ;
       t in
     let rec loop () =
       let accept =
         accept service &gt;&gt;? fun flow -&gt; Lwt.return_ok (`Flow flow) in
       accept &gt;&gt;? function
       | `Flow flow -&gt;
         Lwt.async (fun () -&gt; handler flow) ;
         Lwt.pause () &gt;&gt;= loop in
     let stop_result =
       Lwt.pick [ switched_off; loop () ] &gt;&gt;= function
       | Ok `Stopped -&gt; close service &gt;&gt;= fun () -&gt; Lwt.return_ok ()
       | Error _ as err -&gt; close service &gt;&gt;= fun () -&gt; Lwt.return err in
     stop_result &gt;&gt;= function Ok () | Error _ -&gt; Lwt.return_unit)

let tcp =
  let accept t = Lwt_unix.accept t &gt;&gt;= fun (fd, _) -&gt;
    Lwt.return_ok (TCPRepr.T fd) in
  let close t = Lwt_unix.close t in
  { accept; close; }

let tls cfg =
  let accept t =
    Lwt_unix.accept t &gt;&gt;= fun (fd, _) -&gt;
    TLS'.server_of_flow cfg fd &gt;&gt;? fun fd -&gt;
    Lwt.return_ok (TLSRepr.T fd) in
  let close t = Lwt_unix.close t in
  { accept; close; }

let run03 v service =
  let `Initialized th = serve_when_ready ~handler service v in th

let run03 = function
  | `TCP sockaddr -&gt;
    let domain = Unix.domain_of_sockaddr sockaddr in
    let socket = Lwt_unix.socket domain Unix.SOCK_STREAM 0 in
    Lwt_unix.bind socket sockaddr &gt;&gt;= fun () -&gt;
    Lwt_unix.listen socket 40 ;
    run03 socket tcp
  | `TLS (cfg, sockaddr) -&gt;
    let domain = Unix.domain_of_sockaddr sockaddr in
    let socket = Lwt_unix.socket domain Unix.SOCK_STREAM 0 in
    Lwt_unix.bind socket sockaddr &gt;&gt;= fun () -&gt;
    Lwt_unix.listen socket 40 ;
    run03 socket (tls cfg)

let load_file filename =
  let ic = open_in filename in
  let ln = in_channel_length ic in
  let rs = Bytes.create ln in
  really_input ic rs 0 ln ; close_in ic ;
  Cstruct.of_bytes rs

let certificates_of_files cert key =
  let cert = load_file cert in
  let key  = load_file key in
  match X509.Certificate.decode_pem_multiple cert,
        X509.Private_key.decode_pem key with
  | Ok certs, Ok key -&gt; `Single (certs, key)
  | _ -&gt; Fmt.failwith &quot;Invalid key or certificate&quot;

let () = match Sys.argv with
  | [| _; &quot;server&quot;; port; |] -&gt;
    let sockaddr =
      Unix.ADDR_INET (Unix.inet_addr_loopback, int_of_string port) in
    Lwt_main.run (run03 (`TCP sockaddr))
  | [| _; &quot;server&quot;; cert; key; port; |] -&gt;
    let sockaddr =
      Unix.ADDR_INET (Unix.inet_addr_loopback, int_of_string port) in
    let certificates = certificates_of_files cert key in
    let tls = Tls.Config.server ~certificates () in
    Lwt_main.run (run03 (`TLS (tls, sockaddr)))
  | [| _; &quot;client&quot;; uri; |] -&gt;
    Lwt_main.run (run02 (Uri.of_string uri) stdin)
    |&gt; R.reword_error (R.msgf &quot;%a&quot; Mimic.pp_error)
    |&gt; R.failwith_error_msg
  | [| _; &quot;client&quot;; uri; filename; |] when Sys.file_exists filename -&gt;
    let ic = open_in filename in
    let rs = Lwt_main.run (run02 (Uri.of_string uri) ic) in
    close_in ic ;
    R.failwith_error_msg (R.reword_error (R.msgf &quot;%a&quot; Mimic.pp_error) rs)
  | _ -&gt;
    Fmt.epr &quot;%s server [cert.pem] [key.pem] &lt;port&gt;\n%!&quot; Sys.argv.(0) ;
    Fmt.epr &quot;%s client &lt;uri&gt; [filename]\n%!&quot; Sys.argv.(0)</code></pre></div></body></html>
